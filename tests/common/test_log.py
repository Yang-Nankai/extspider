# -*- coding: utf-8 -*-
from unittest import TestCase
import logging
import os

from extspider.common import log


class TestLogging(TestCase):
    """
    TestLogging ensures correct functionality of the logging suite
    """

    def setUp(self) -> None:
        self.rename_log_to_temporary_name()


    def tearDown(self) -> None:
        self.remove_test_and_reinstate_actual_log()


    def read_test_log_content(self) -> str:
        """
        test_log_content

        Returns:
            str: logs generated while running the test suite
        """

        content = None
        with open(log.LOG_FILE_PATH, "r", encoding="utf-8") as log_file:
            content = log_file.read()

        return content


    def rename_log_to_temporary_name(self) -> None:
        """
        rename_log_to_temporary checks if a log file already exists and, if it
        does, renames it to a temporary name
        """
        self.log_exists = True
        try:
            os.rename(log.LOG_FILE_PATH, f"{log.LOG_FILE_PATH}.actual")
        except FileNotFoundError:
            self.log_exists = False


    def remove_test_and_reinstate_actual_log(self) -> None:
        """
        remove_test_and_reinstate_actual_log removes log generated by test and,
        if a log file existed before test, reverts it to original naming
        """
        logging.shutdown()
        os.remove(log.LOG_FILE_PATH)
        if self.log_exists:
            os.rename(f"{log.LOG_FILE_PATH}.actual", log.LOG_FILE_PATH)


    def test_logger(self):
        """
        test_get_logger ensures functionality of the logging object
        """
        logger_name = "test_get_logger"
        logger_output = "Testing logging functionality"
        logger_output_types = ["DEBUG",
                               "INFO",
                               "WARNING",
                               "ERROR",
                               "CRITICAL"]

        logger = log.get_logger(logger_name, logging.DEBUG)
        logger.debug(logger_output)
        logger.info(logger_output)
        logger.warning(logger_output)
        logger.error(logger_output)
        logger.critical(logger_output)

        logged_content = self.read_test_log_content()
        self.assertIsNotNone(logged_content)
        self.assertEqual(type(logged_content), str)
        self.assertGreater(len(logged_content), 0)

        # Split lines and remove the last one (end-of-file EOF)
        logged_lines = logged_content.split("\n")[:-1]
        self.assertEqual(len(logged_lines), len(logger_output_types))

        for index, line in enumerate(logged_lines):
            line_sections = line.split(" - ")
            # Ignore line_sections[0] as it is a timestamp
            self.assertEqual(line_sections[1], logger_name)
            self.assertEqual(line_sections[2], logger_output_types[index])
            self.assertEqual(line_sections[3], logger_output)


    def test_monitor_function(self):
        """
        test_monitor_function ensures functionality of the monitor_function
        decorator
        """
        sample_positional_arguments = ["test_positional_argument",
                                       (str, self),
                                       0]
        sample_keyword_arguments = {"d": "test_keyword_argument"}
        sample_return_value = "test_return_string"

        @log.monitor_function
        def sample_function_to_be_monitored(*args, **kwargs):
            del args
            del kwargs
            return sample_return_value

        sample_function_to_be_monitored(*sample_positional_arguments,
                                        **sample_keyword_arguments)

        input_representation = log.generate_arguments_representation(
            *sample_positional_arguments, **sample_keyword_arguments)
        expected_input_log = f"Arguments: {input_representation}"
        expected_output_log = f"Returned: {repr('test_return_string')}"

        logged_content = self.read_test_log_content()
        self.assertIsNotNone(logged_content)
        self.assertEqual(type(logged_content), str)
        self.assertGreater(len(logged_content), 0)

        # Split lines and remove the last one (end-of-file EOF)
        logged_lines = logged_content.split("\n")[:-1]
        self.assertEqual(len(logged_lines), 2)

        arguments_line = logged_lines[0].split(" - ")
        self.assertEqual(arguments_line[-1], expected_input_log)

        return_line = logged_lines[1].split(" - ")
        self.assertEqual(return_line[-1], expected_output_log)
